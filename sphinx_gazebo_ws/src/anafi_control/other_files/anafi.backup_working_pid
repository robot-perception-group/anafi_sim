#!/usr/bin/env python3

import rospy
import csv
import cv2
import math
import os
import requests
import queue
import shlex
import subprocess
import tempfile
import threading
import traceback
import time
import datetime
import logging
import roslib
import sys
import yaml
import olympe

import numpy as np

import re
import shutil
import xml.etree.ElementTree as ET

from std_msgs.msg import UInt8, UInt16, UInt32, UInt64, Int8, Float32, String, Header, Time, Bool
from geometry_msgs.msg import PoseStamped, PointStamped, QuaternionStamped, TwistStamped, Vector3Stamped, Quaternion, Twist, Vector3
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Image, CameraInfo, NavSatFix
from std_srvs.srv import Empty, SetBool
from tf.transformations import euler_from_quaternion
from cv_bridge import CvBridge, CvBridgeError

from olympe.messages.drone_manager import connection_state
from olympe.messages.ardrone3.Piloting import TakeOff, UserTakeOff, Landing, Emergency, PCMD, NavigateHome, moveTo
from olympe.messages.ardrone3.PilotingState import FlyingStateChanged, PositionChanged, SpeedChanged, AttitudeChanged, AltitudeChanged, GpsLocationChanged
from olympe.messages.ardrone3.PilotingSettings import MaxTilt, MaxDistance, MaxAltitude, NoFlyOverMaxDistance, BankedTurn
from olympe.messages.ardrone3.PilotingSettingsState import MaxTiltChanged, MaxDistanceChanged, MaxAltitudeChanged, NoFlyOverMaxDistanceChanged, BankedTurnChanged
from olympe.messages.ardrone3.SpeedSettings import MaxVerticalSpeed, MaxRotationSpeed, MaxPitchRollRotationSpeed
from olympe.messages.ardrone3.SpeedSettingsState import MaxVerticalSpeedChanged, MaxRotationSpeedChanged, MaxPitchRollRotationSpeedChanged
from olympe.messages.ardrone3.GPSSettingsState import GPSFixStateChanged
from olympe.messages.ardrone3.GPSState import NumberOfSatelliteChanged
from olympe.messages.piloting_style import set_style
from olympe.messages.controller_info import validity_from_drone
from olympe.messages.precise_home import set_mode as precise_home_set_mode
from olympe.messages.rth import return_to_home, abort, set_ending_behavior, set_ending_hovering_altitude, set_min_altitude
from olympe.messages.skyctrl.CoPiloting import setPilotingSource
from olympe.messages.skyctrl.CoPilotingState import pilotingSource
from olympe.messages.skyctrl.Common import AllStates
from olympe.messages.skyctrl.CommonState import AllStatesChanged
from olympe.messages import gimbal, camera, mapper, leds, follow_me, controller_info
from olympe.messages.camera import photo_progress, take_photo, set_photo_mode
from olympe.media import download_media, indexing_state, delete_media, delete_all_media
from olympe.messages.mediastore import state as mediastore_state_message
from olympe.enums.ardrone3.PilotingState import AlertStateChanged_State, ForcedLandingAutoTrigger_Reason
from olympe.enums.camera import availability, state
from olympe.enums.piloting_style import style
from olympe.enums.precise_home import mode as precise_home_mode
from olympe.enums.mediastore import state as mediastore_state_enum
from olympe.messages.thermal import capabilities
from olympe.messages.move import extended_move_by, extended_move_to

import pyproj as pp

from olympe_bridge.transformation_GPS import GPS2ECEF, ECEF2NED, GPS2NED
from tf.transformations import quaternion_multiply

from olympe.messages.common.Common import AllStates

from olympe.messages.ardrone3.GPSSettings import SendControllerGPS
# from olympe.messages.follow_me import Start, ConfigureGeographic, Stop


from dynamic_reconfigure.server import Server
from olympe_bridge.cfg import setAnafiConfig
from olympe_bridge.msg import PilotingCommand, MoveByCommand, MoveToCommand, CameraCommand, GimbalCommand, SkycontrollerCommand, TargetTrajectory
from olympe_bridge.srv import PilotedPOI, FlightPlan, FollowMe, Location, String as StringSRV

import olympe_bridge
from anafi_control.msg import State

olympe.log.update_config({"loggers": {"olympe": {"level": "ERROR"}}})


def bound(value, value_min, value_max):
	return min(max(value, value_min), value_max)


def bound_percentage(value):
	return bound(value, -100, 100)


class Anafi(threading.Thread):
	models = {2324:"4k", 2329:"thermal", 2334:"usa", 0000:"ai"}

	def __init__(self):
		# Publishers
		self.pub_image = rospy.Publisher("camera/image", Image, queue_size=1)
		self.pub_camera_info = rospy.Publisher("camera/camera_info", CameraInfo, queue_size=1)
		self.pub_time = rospy.Publisher("time", Time, queue_size=1)
		self.pub_attitude = rospy.Publisher("drone/attitude", QuaternionStamped, queue_size=1)
		self.pub_altitude = rospy.Publisher("drone/altitude", Float32, queue_size=1)
		self.pub_speed = rospy.Publisher("drone/speed", Vector3Stamped, queue_size=1)
		self.pub_location = rospy.Publisher("drone/location", NavSatFix, queue_size=1)
		self.pub_position_enu = rospy.Publisher("drone/position_enu", PointStamped, queue_size=1)
		self.pub_pose_enu = rospy.Publisher("drone/pose_enu", PoseStamped, queue_size=1)
		self.pub_link_goodput = rospy.Publisher("link/goodput", UInt16, queue_size=1)
		self.pub_link_quality = rospy.Publisher("link/quality", UInt8, queue_size=1)
		self.pub_wifi_rssi = rospy.Publisher("link/rssi", Int8, queue_size=1)
		self.pub_battery = rospy.Publisher("drone/battery", UInt8, queue_size=1)
		self.pub_state = rospy.Publisher("drone/state", String, queue_size=1)
		self.pub_rpy = rospy.Publisher("drone/rpy", Vector3Stamped, queue_size=1)
		self.pub_camera_attitude = rospy.Publisher("camera/attitude", QuaternionStamped, queue_size=1)
		self.pub_camera_base_attitude = rospy.Publisher("camera/base/attitude", QuaternionStamped, queue_size=1)
		self.pub_exposure_time = rospy.Publisher("camera/exposure_time", Float32, queue_size=1)
		self.pub_iso_gain = rospy.Publisher("camera/iso_gain", UInt16, queue_size=1)
		self.pub_awb_r_gain = rospy.Publisher("camera/awb_r_gain", Float32, queue_size=1)
		self.pub_awb_b_gain = rospy.Publisher("camera/awb_b_gain", Float32, queue_size=1)
		self.pub_hfov = rospy.Publisher("camera/hfov", Float32, queue_size=1)
		self.pub_vfov = rospy.Publisher("camera/vfov", Float32, queue_size=1)
		self.pub_gps_fix = rospy.Publisher("drone/gps/fix", Bool, queue_size=1)
		self.pub_steady = rospy.Publisher("drone/steady", Bool, queue_size=1)
		self.pub_battery_health = rospy.Publisher("battery/health", UInt8, queue_size=1)
		self.pub_home_location = rospy.Publisher("home/location", PointStamped, queue_size=1)
		self.pub_skyctrl_command = rospy.Publisher("skycontroller/command", SkycontrollerCommand, queue_size=1)

		self.pub_control_state = rospy.Publisher("position_control/state_enu",State,queue_size=1)

		# Subscribers
		rospy.Subscriber("drone/rpyt", PilotingCommand, self.rpyt_callback)
		rospy.Subscriber("drone/moveto", MoveToCommand, self.moveTo_callback)
		rospy.Subscriber("drone/moveby", MoveByCommand, self.moveBy_callback)
		rospy.Subscriber("camera/cmd", CameraCommand, self.zoom_callback)
		rospy.Subscriber("gimbal/cmd", GimbalCommand, self.gimbal_callback)
		rospy.Subscriber("drone/location_spawn_point_enu", PointStamped, self.spawn_point_callback)


		rospy.Subscriber("update_controller_gps",MoveToCommand,self.update_controller_gps)
		
		# Services
		rospy.Service('drone/arm', SetBool, self.arm)
		rospy.Service('drone/takeoff', Empty, self.takeoff)
		rospy.Service('drone/land', Empty, self.land)
		rospy.Service('drone/emergency', Empty, self.emergency)
		rospy.Service('drone/halt', Empty, self.halt)
		rospy.Service('drone/rth', Empty, self.rth)
		rospy.Service('drone/reboot', Empty, self.reboot)
		rospy.Service('drone/calibrate', Empty, self.magnetometer_calibrate)
		rospy.Service('skycontroller/offboard', SetBool, self.offboard)
		rospy.Service('skycontroller/discover', Empty, self.manager_discover)
		rospy.Service('skycontroller/forget', StringSRV, self.manager_forget)
		rospy.Service('home/set', Location, self.home_set)
		rospy.Service('home/navigate', SetBool, self.home_navigate)
		rospy.Service('POI/start', PilotedPOI, self.POI_start)
		rospy.Service('POI/stop', Empty, self.POI_stop)
		rospy.Service('flightplan/upload', FlightPlan, self.flightplan_upload)
		rospy.Service('flightplan/start', FlightPlan, self.flightplan_start)
		rospy.Service('flightplan/pause', Empty, self.flightplan_pause)
		rospy.Service('flightplan/stop', Empty, self.flightplan_stop)
		rospy.Service('followme/start', FollowMe, self.followme_start)
		rospy.Service('followme/stop', Empty, self.followme_stop)
		rospy.Service('gimbal/reset', Empty, self.gimbal_reset)
		rospy.Service('gimbal/calibrate', Empty, self.gimbal_calibrate)
		rospy.Service('camera/reset', Empty, self.zoom_reset)
		rospy.Service('camera/photo/take', Empty, self.photo_take)
		# rospy.Service('camera/photo/take_and_download', Empty, self.photo_take_and_download)
		rospy.Service('camera/photo/stop', Empty, self.photo_stop)
		rospy.Service('camera/recording/start', Empty, self.recording_start)
		rospy.Service('camera/recording/stop', Empty, self.recording_stop)
		rospy.Service('storage/download', Empty, self.media_download)
		rospy.Service('storage/format', Empty, self.storage_format)
		
		# Messages
		self.header = Header()
		self.msg_camera_info = CameraInfo()
		self.msg_time = Time()
		self.msg_attitude = QuaternionStamped()
		self.msg_rpy = Vector3Stamped()
		self.msg_speed = Vector3Stamped()
		self.msg_location = NavSatFix()
		self.msg_home_location = PointStamped()
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.frame_id = 'body'	
		self.msg_home_location = PointStamped()
		self.msg_spawn_point = PointStamped()
		self.msg_control_state = State()

		# Defined in the launch file
		self.model = rospy.get_param("model")
		self.ip = rospy.get_param("ip")
		self.drone_serial = rospy.get_param("drone_serial")
		self.wifi_key = rospy.get_param("wifi_key")
		self.rest_api_version = rospy.get_param("rest_api_version")
		self.skycontroller_enabled = rospy.get_param("skycontroller_enabled")
		
		if self.skycontroller_enabled:  # connect to SkyController
			rospy.loginfo("Connecting through SkyController")
		else:  # connect to Anafi
			rospy.loginfo("Connecting directly to Anafi")
		self.drone = olympe.Drone(self.ip)
		self.skyctrl = self.drone

		# Create event listeners
		self.event_listener_anafi = olympe_bridge.EventListenerAnafi(self)
		self.event_listener_skycontroller = olympe_bridge.EventListenerSkyController(self)

		self.bridge = CvBridge()  # to convert OpenCV images to ROS images

		self.state = 'LANDED'
		self.gps_fixed = False

		rospy.on_shutdown(self.stop)

		self.connect()

		self.srv = Server(setAnafiConfig, self.reconfigure_callback)

		if self.skycontroller_enabled:
			#model = self.drone.get_state(olympe.messages.drone_manager.known_drone_item).popitem(last=False)[1]['model'] # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.known_drone_item
			model = self.drone.get_state(olympe.messages.mapper.active_product)['product'] # https://developer.parrot.com/docs/olympe/arsdkng_mapper.html#olympe.messages.mapper.active_product
			self.model = self.models.get(model, self.model)
		rospy.loginfo('Drone model: ' + self.model)

		if self.model in {"4k", "thermal", "usa", "ai"}:
			with open(os.path.abspath(os.path.dirname(__file__) + "/../../config/camera_" + self.model + ".yaml"), "r") as file_handle: # load camera info from file
				camera_info = yaml.load(file_handle, Loader=yaml.FullLoader)
			rospy.loginfo("Camera info loaded from " + os.path.abspath(os.path.dirname(__file__) + "/../../config/camera_" + self.model + ".yaml"))
			# Parse camera info		
			self.msg_camera_info.width = camera_info['image_width']
			self.msg_camera_info.height = camera_info['image_height']
			self.msg_camera_info.K = camera_info['camera_matrix']['data']
			self.msg_camera_info.D = camera_info['distortion_coefficients']['data']
			self.msg_camera_info.R = camera_info['rectification_matrix']['data']
			self.msg_camera_info.P = camera_info['projection_matrix']['data']
			self.msg_camera_info.distortion_model = camera_info['distortion_model']
		else:
			rospy.logerr("Model " + self.model + " is not supported")
		
		self.drone(camera.set_antiflicker_mode(mode="auto")) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_antiflicker_mode
		self.drone(camera.set_white_balance(cam_id=0, mode="automatic", temperature="t_8000")) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_white_balance
		self.drone(camera.set_zoom_velocity_quality_degradation(cam_id=0, allow=1)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_zoom_velocity_quality_degradation
		self.drone(NoFlyOverMaxDistance(shouldNotFlyOver=1)) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.NoFlyOverMaxDistance
		self.drone(olympe.messages.user_storage.start_monitoring(period=1)) # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.start_monitoring
		
		if self.skycontroller_enabled:
			self.drone(olympe.messages.skyctrl.Calibration.enableMagnetoCalibrationQualityUpdates(enable=1)) # https://developer.parrot.com/docs/olympe/arsdkng_skyctrl_calibration.html#olympe.messages.skyctrl.Calibration.enableMagnetoCalibrationQualityUpdates
		
		rospy.logdebug('Drone name: ' + str(self.drone.get_state(olympe.messages.common.SettingsState.ProductNameChanged)['name'])) # https://developer.parrot.com/docs/olympe/arsdkng_common_settings.html#olympe.messages.common.SettingsState.ProductNameChanged
		rospy.logdebug('Drone serial: ' + str(self.drone.get_state(olympe.messages.common.SettingsState.ProductSerialHighChanged)['high']) + str(self.drone.get_state(olympe.messages.common.SettingsState.ProductSerialLowChanged)['low'])) # 
		drone_version = self.drone.get_state(olympe.messages.common.SettingsState.ProductVersionChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_settings.html#olympe.messages.common.SettingsState.ProductVersionChanged
		rospy.logdebug('Drone version: software: %s, hardware: %s', drone_version['software'], drone_version['hardware'])
		flights_status = self.drone.get_state(olympe.messages.ardrone3.SettingsState.MotorFlightsStatusChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_settings_state.html#olympe.messages.ardrone3.SettingsState.MotorErrorStateChanged
		rospy.loginfo('Number of flights: %i', flights_status['nbFlights'])
		rospy.loginfo('Total flight duration: %s', str(datetime.timedelta(seconds=flights_status['totalFlightDuration'])))
		rospy.logdebug('Battery serial: %s', self.drone.get_state(olympe.messages.battery.serial)['serial']) # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.serial
		rospy.loginfo('Battery cycle count: %i', self.drone.get_state(olympe.messages.battery.cycle_count)['count']) # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.cycle_count
		rospy.loginfo('Battery health: %i%%', self.drone.get_state(olympe.messages.battery.health)['state_of_health']) # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.health
		rospy.logdebug('Camera states: ' + str(self.drone.get_state(olympe.messages.camera.camera_states))) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.camera_states
		rospy.logdebug('Camera capabilities: ' + str(self.drone.get_state(olympe.messages.camera.camera_capabilities))) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.camera_capabilities	
		rospy.logdebug('Recording capabilities: ' + str(self.drone.get_state(olympe.messages.camera.recording_capabilities))) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.recording_capabilities
				
		max_tilt = self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.MaxTiltChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.MaxTiltChanged
		rospy.logdebug('MaxTilt = %f [%f, %f]', max_tilt["current"], max_tilt["min"], max_tilt["max"])
		max_vertical_speed = self.drone.get_state(olympe.messages.ardrone3.SpeedSettingsState.MaxVerticalSpeedChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettingsState.MaxVerticalSpeedChanged
		rospy.logdebug('MaxVerticalSpeed = %f [%f, %f]', max_vertical_speed["current"], max_vertical_speed["min"], max_vertical_speed["max"])
		max_rotation_speed = self.drone.get_state(olympe.messages.ardrone3.SpeedSettingsState.MaxRotationSpeedChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettingsState.MaxRotationSpeedChanged
		rospy.logdebug('MaxRotationSpeed = %f [%f, %f]', max_rotation_speed["current"], max_rotation_speed["min"], max_rotation_speed["max"])
		max_pitch_roll_rotation_speed = self.drone.get_state(olympe.messages.ardrone3.SpeedSettingsState.MaxPitchRollRotationSpeedChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettingsState.MaxPitchRollRotationSpeedChanged
		rospy.logdebug('MaxPitchRollRotationSpeed = %f [%f, %f]', max_pitch_roll_rotation_speed["current"], max_pitch_roll_rotation_speed["min"], max_pitch_roll_rotation_speed["max"])
		max_distance = self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.MaxDistanceChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.MaxDistanceChanged
		rospy.logdebug('MaxDistance = %f [%f, %f]', max_distance["current"], max_distance["min"], max_distance["max"])
		max_altitude = self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.MaxAltitudeChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.MaxAltitudeChanged
		rospy.logdebug('MaxAltitude = %f [%f, %f]', max_altitude["current"], max_altitude["min"], max_altitude["max"])
		rospy.logdebug('NoFlyOverMaxDistance = %i', self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged)["shouldNotFlyOver"]) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged
		rospy.logdebug('BankedTurn = %i', self.drone.get_state(olympe.messages.ardrone3.PilotingSettingsState.BankedTurnChanged)["state"]) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettingsState.BankedTurnChanged
		absolute_attitude_bounds = self.drone.get_state(olympe.messages.gimbal.absolute_attitude_bounds)[0] # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.absolute_attitude_bounds
		rospy.logdebug('GimbalAbsoluteBounds (deg): roll=[%f, %f], pitch=[%f, %f], yaw=[%f, %f]', absolute_attitude_bounds["min_roll"], absolute_attitude_bounds["max_roll"], absolute_attitude_bounds["min_pitch"], absolute_attitude_bounds["max_pitch"], absolute_attitude_bounds["min_yaw"], absolute_attitude_bounds["max_yaw"])
		relative_attitude_bounds = self.drone.get_state(olympe.messages.gimbal.relative_attitude_bounds)[0] # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.relative_attitude_bounds
		rospy.logdebug('GimbalRelativeBounds (deg): roll=[%f, %f], pitch=[%f, %f], yaw=[%f, %f]', relative_attitude_bounds["min_roll"], relative_attitude_bounds["max_roll"], relative_attitude_bounds["min_pitch"], relative_attitude_bounds["max_pitch"], relative_attitude_bounds["min_yaw"], relative_attitude_bounds["max_yaw"])
		max_speed = self.drone.get_state(olympe.messages.gimbal.max_speed)[0] # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.max_speed
		rospy.logdebug('GimbalMaxSpeed (deg/s): roll=%f [%f, %f], pitch=%f [%f, %f], yaw=%f [%f, %f]', max_speed["current_roll"], max_speed["min_bound_roll"], max_speed["max_bound_roll"], max_speed["current_pitch"], max_speed["min_bound_pitch"], max_speed["max_bound_pitch"], max_speed["current_yaw"], max_speed["min_bound_yaw"], max_speed["max_bound_yaw"])
		
		if self.skycontroller_enabled:
			skyctrl_version = self.drone.get_state(olympe.messages.skyctrl.SettingsState.ProductVersionChanged) # https://developer.parrot.com/docs/olympe/arsdkng_skyctrl_settings.html#olympe.messages.skyctrl.SettingsState.ProductVersionChanged
			rospy.logdebug('Controller version: software=%s, hardware=%s', skyctrl_version['software'], skyctrl_version['hardware'])
			rospy.logdebug('Validity from drone: %r ', self.drone.get_state(validity_from_drone)["is_valid"] == 1) # https://developer.parrot.com/docs/olympe/arsdkng_controller_info.html#olympe.messages.controller_info.validity_from_drone
		
		mediastore_state = self.drone.get_state(mediastore_state_message)['state'] # https://developer.parrot.com/docs/olympe/arsdkng_mediastore.html#olympe.messages.mediastore.state
		if mediastore_state == mediastore_state_enum.not_available:
			rospy.logerr('Mediastore state is not available')
		else:
			if mediastore_state == mediastore_state_enum.indexing:
				rospy.logwarn('Mediastore state is indexig')
			else:
				rospy.loginfo('Mediastore state is indexed')
				
		#if self.model in {"thermal", "usa"}:
		#	rospy.logwarn('thermal_capabilities: ' + str(self.drone.get_state(capabilities)))
		#	self.drone(olympe.messages.thermal.set_mode(mode='standard')).wait() # https://developer.parrot.com/docs/olympe/arsdkng_thermal.html#olympe.messages.thermal.set_mode
		#	rospy.logwarn('thermal_mode: ' + str(self.drone.get_state(olympe.messages.thermal.mode)))
		#	self.drone(olympe.messages.thermal.set_rendering(mode='blended', blending_rate=0.5)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_thermal.html#olympe.messages.thermal.set_rendering
		#	rospy.logwarn('rendering: ' + str(self.drone.get_state(olympe.messages.thermal.rendering)))

		# Setup the callback functions to do some live video processing
		self.processing_thread = threading.Thread(target=self.yuv_frame_processing)
		self.drone.streaming.set_callbacks(
			raw_cb=self.yuv_frame_cb,
			flush_raw_cb=self.flush_cb)
		self.drone.streaming.start(media_name="DefaultVideo")
		self.processing_thread.start()
										
	def connect(self):
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.frame_id = 'body'

		self.running = False

		rate = rospy.Rate(1) # 1hz
		while True:
			self.pub_state.publish("CONNECTING")
			if self.drone_serial != "":
				rospy.loginfo_once("Connecting to %s with %s", self.drone_serial, self.wifi_key)
				self.drone(olympe.messages.drone_manager.connect(  # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.connect
					serial=self.drone_serial,
					key=self.wifi_key
				)).wait()  # TODO: check why sometimes doesn't connect
				if self.drone(connection_state(state="connected", _policy="check")):  # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.enums.drone_manager.connection_state
					break
			else:
				if self.drone.connect():
					break
			if rospy.is_shutdown():
				exit()
			rate.sleep()

		if self.skycontroller_enabled: # connect to the SkyController
			self.pub_state.publish("CONNECTED_SKYCONTROLLER")
			rospy.loginfo("Connected to SkyController")
			self.switch_manual()
					
			while True: # connect to the drone
				if self.drone(connection_state(state="connected", _policy="check")):
					break				
				if rospy.is_shutdown():
					exit()
				else:
					self.pub_state.publish("SERCHING_DRONE")
					rospy.loginfo_once("Connection to Anafi: " + self.drone.get_state(connection_state)["state"].name)
				rate.sleep()
			self.pub_state.publish("CONNECTED_DRONE")			
			rospy.loginfo("Connection to Anafi: " + self.drone.get_state(connection_state)["state"].name)
		else: # connect to the Anafi
			self.pub_state.publish("CONNECTED_DRONE")
			rospy.loginfo("Connected to Anafi")
			self.switch_offboard()
			
		rospy.logdebug('Boot Id: ' + self.drone.get_state(olympe.messages.common.CommonState.BootId)['bootId']) # https://developer.parrot.com/docs/olympe/arsdkng_common_common.html#olympe.messages.common.CommonState.BootId

		self.running = True

		self.event_listener_anafi.subscribe()
		self.event_listener_skycontroller.subscribe()

		self.fast_timer = rospy.Timer(rospy.Duration(0.01), self.fast_callback)
		self.slow_timer = rospy.Timer(rospy.Duration(1.00), self.slow_callback)

		self.frame_queue = queue.Queue(maxsize=1)  # TODO: replace by a shared variable
		
	def disconnect(self):
		self.pub_state.publish("DISCONNECTING")
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.stamp = rospy.Time.now()
		self.pub_skyctrl_command.publish(self.msg_skycontroller)

		if self.running:  # disconnecting before started publishing anything
			self.running = False
			self.event_listener_anafi.unsubscribe()
			self.event_listener_skycontroller.unsubscribe()
			self.fast_timer.shutdown()
			self.slow_timer.shutdown()
			self.processing_thread.join()
			self.drone.streaming.stop()

		self.drone.disconnect()
		self.pub_state.publish("DISCONNECTED")
		
	def stop(self):
		rospy.loginfo("Anafi_bridge is stopping...")
		self.disconnect()
						
	def reconfigure_callback(self, config, level):
		if level == -1 or level == 1:  # piloting related
			self.drone(MaxTilt(config['max_tilt']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html?#olympe.messages.ardrone3.PilotingSettings.MaxTilt
			self.drone(MaxVerticalSpeed(config['max_vertical_speed']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxVerticalSpeed
			self.drone(MaxRotationSpeed(config['max_yaw_rotation_speed']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxRotationSpeed
			self.drone(MaxPitchRollRotationSpeed(config['max_pitch_roll_rotation_speed']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.SpeedSettings.MaxPitchRollRotationSpeed
			self.drone(MaxDistance(config['max_distance']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.MaxDistance
			self.drone(MaxAltitude(config['max_altitude']))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.MaxAltitude
			self.drone(BankedTurn(int(config['banked_turn'])))  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingSettings.BankedTurn
			self.drone(set_style(style=style(int(config['camera_operated']))))  # https://developer.parrot.com/docs/olympe/arsdkng_piloting_style.html#olympe.messages.piloting_style.set_style
			self.max_tilt = config['max_tilt']
			self.max_horizontal_speed = config['max_horizontal_speed']
			self.max_vertical_speed = config['max_vertical_speed']
			self.max_rotation_speed = config['max_yaw_rotation_speed']
		if level == -1 or level == 2:  # RTH related
			self.drone(olympe.messages.rth.set_preferred_home_type(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_preferred_home_type
				type=olympe.enums.rth.home_type(int(config['home_type']))))  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.enums.rth.home_type
			self.drone(set_ending_behavior(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_ending_behavior
				ending_behavior='landing' if config['ending_behavior'] == 0 else 'hovering'))  # {'landing', 'hovering'}
			self.drone(set_ending_hovering_altitude(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_ending_hovering_altitude
				altitude=config['hovering_altitude']))  # AGL altitude (m)
			self.drone(set_min_altitude(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_min_altitude
				altitude=config['min_altitude']))  # ATO altitude (m)
			self.drone(olympe.messages.rth.set_auto_trigger_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.set_auto_trigger_mode
				mode=olympe.enums.rth.auto_trigger_mode(int(config['auto_trigger']))))  # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.enums.rth.auto_trigger_mode
			self.drone(precise_home_set_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_precise_home.html#olympe.messages.precise_home.set_mode
				mode=precise_home_mode(int(config['precise_home']))))  # https://developer.parrot.com/docs/olympe/arsdkng_precise_home.html#olympe.enums.precise_home.mode
		if level == -1 or level == 3: # camera related	
			self.camera_mode = config['camera_mode']
			self.drone(camera.set_camera_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_camera_mode
				cam_id=0,
				value=olympe.enums.camera.camera_mode(self.camera_mode)))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.camera_mode
			self.drone(camera.set_ev_compensation(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_ev_compensation
				cam_id=0,
				value=olympe.enums.camera.ev_compensation(config['ev_compensation'])))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.ev_compensation
			self.drone(camera.set_hdr_setting(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_hdr_setting
				cam_id=0,
				value=availability.available if config['hdr'] else availability.not_available))  # CHECK for a potencial bug
			self.drone(camera.set_max_zoom_speed(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_max_zoom_speed
				cam_id=0,
				max=config['max_zoom_speed']))  # [0.01, 10] (tan(deg)/sec)
			self.drone(camera.set_streaming_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_streaming_mode
				cam_id=0,
				value=olympe.enums.camera.streaming_mode(config['streaming_mode'])))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.streaming_mode
			self.drone(camera.set_style(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_style
				cam_id=0,
				style=olympe.enums.camera.style(config['image_style'])))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.style
		if level == -1 or level == 4:  # photo related
			self.drone(camera.set_photo_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_photo_mode
				cam_id=0,
				mode=olympe.enums.camera.photo_mode(config['photo_mode']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_mode
				format=olympe.enums.camera.photo_format(config['photo_format']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_format
				file_format=olympe.enums.camera.photo_file_format(config['file_format']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_file_format
				burst=olympe.enums.camera.burst_value.burst_14_over_1s,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.photo_file_format
				bracketing=olympe.enums.camera.bracketing_preset.preset_1ev_2ev_3ev,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.bracketing_preset
				capture_interval=1))  # (s\time_lapse, m\gps_lapse)
		if level == -1 or level == 5:  # video related
			self.drone(camera.set_autorecord(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_autorecord
				cam_id=0,
				state="active" if config['autorecord'] else "inactive"))
			if config['recording_mode'] == 0 or config['recording_mode'] == 1:  # standard OR hyperlapse
				self.drone(camera.set_recording_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_recording_mode
					cam_id=0,
					mode=olympe.enums.camera.recording_mode(config['recording_mode']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.recording_mode
					resolution=olympe.enums.camera.resolution.res_1080p,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.resolution
					framerate=olympe.enums.camera.framerate.fps_30,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.framerate
					hyperlapse=olympe.enums.camera.hyperlapse_value.ratio_15))  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.hyperlapse
			if config['recording_mode'] == 2 or config['recording_mode'] == 3:  # slow_motion OR high_framerate
				self.drone(camera.set_recording_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_recording_mode
					cam_id=0,
					mode=olympe.enums.camera.recording_mode(config['recording_mode']),  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.recording_modeoffboard
					resolution=olympe.enums.camera.resolution.res_720p,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.resolution
					framerate=olympe.enums.camera.framerate.fps_120,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.framerate
					hyperlapse=olympe.enums.camera.hyperlapse_value(0)))  # not used
			if config['recording_mode'] == 4:  # high_resolution
				self.drone(camera.set_recording_mode(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_recording_mode
					cam_id=0,
					mode=olympe.enums.camera.recording_mode.standard,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.recording_mode
					resolution=olympe.enums.camera.resolution.res_dci_4k,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.resolution
					framerate=olympe.enums.camera.framerate.fps_24,  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.enums.camera.framerate
					hyperlapse=olympe.enums.camera.hyperlapse_value(0)))  # not used
		if level == -1 or level == 6:  # media download related
			self.download_folder = config['download_folder']
			self.cut_media = config['cut_media']
		if level == -1 or level == 7:  # gimbal related
			self.gimbal_frame = 'absolute' if config['gimbal_absolute'] else 'relative'
			self.drone(gimbal.set_max_speed(  # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.max_speed
				gimbal_id=0,
				yaw=0, 
				pitch=config['max_gimbal_speed'],  # [1, 180] (deg/s)
				roll=config['max_gimbal_speed']))  # [1, 180] (deg/s)
			self.max_gimbal_speed = config['max_gimbal_speed']	
		return config
		
	def rpyt_callback(self, msg):
		self.drone(PCMD(  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.PCMD
			flag=1,
			roll=int(bound_percentage(msg.roll/self.max_tilt*100)),  # roll [-100, 100] (% of max tilt)
			pitch=int(bound_percentage(msg.pitch/self.max_tilt*100)),  # pitch [-100, 100] (% of max tilt)
			yaw=int(bound_percentage(-msg.yaw/self.max_rotation_speed*100)),  # yaw rate [-100, 100] (% of max yaw rate)
			gaz=int(bound_percentage(msg.gaz/self.max_vertical_speed*100)),  # vertical speed [-100, 100] (% of max vertical speed)
			timestampAndSeqNum=0))
		


	def moveBy_callback(self, msg):	
		self.drone(extended_move_by( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_by
		d_x=msg.dx, # displacement along the front axis (m)
		d_y=msg.dy, # displacement along the right axis (m)
		d_z=msg.dz, # displacement along the down axis (m)
		d_psi=msg.dyaw, # rotation of heading (rad)
		max_horizontal_speed=self.max_horizontal_speed,
		max_vertical_speed=self.max_vertical_speed,
		max_yaw_rotation_speed=self.max_rotation_speed,
		# _timeout=0.1
		))



		# assert self.drone(extended_move_by( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_by
		# 	d_x=msg.dx, # displacement along the front axis (m)
		# 	d_y=msg.dy, # displacement along the right axis (m)
		# 	d_z=msg.dz, # displacement along the down axis (m)
		# 	d_psi=msg.dyaw, # rotation of heading (rad)
		# 	max_horizontal_speed=self.max_horizontal_speed,
		# 	max_vertical_speed=self.max_vertical_speed,
		# 	max_yaw_rotation_speed=self.max_rotation_speed
		# 	)).wait().success()
	
	def moveTo_callback(self, msg):		
		self.drone(extended_move_to( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_to
			latitude=msg.latitude, # latitude (degrees)
			longitude=msg.longitude, # longitude (degrees)
			altitude=msg.altitude, # altitude (m)
			orientation_mode='heading_start', # orientation mode {'to_target', 'heading_start', 'heading_during'}
			heading=msg.heading, # heading relative to the North (degrees)
			max_horizontal_speed=self.max_horizontal_speed,
			max_vertical_speed=self.max_vertical_speed,
			max_yaw_rotation_speed=self.max_rotation_speed,	
			_no_expect = True,
			_timeout = 0.2
			))
		
		return
		

		# assert self.drone(extended_move_to( # https://developer.parrot.com/docs/olympe/arsdkng_move.html?#olympe.messages.move.extended_move_to
		# 	latitude=msg.latitude, # latitude (degrees)
		# 	longitude=msg.longitude, # longitude (degrees)
		# 	altitude=msg.altitude, # altitude (m)
		# 	orientation_mode='heading_start', # orientation mode {'to_target', 'heading_start', 'heading_during'}
		# 	heading=msg.heading, # heading relative to the North (degrees)
		# 	max_horizontal_speed=self.max_horizontal_speed,
		# 	max_vertical_speed=self.max_vertical_speed,
		# 	max_yaw_rotation_speed=self.max_rotation_speed			
		# 	)).wait().success()

	def update_controller_gps(self,msg):
		# self.drone(
		# 	SendControllerGPS(
		# 		latitude=msg.latitude,
		# 		longitude=msg.longitude,
		# 		altitude=msg.altitude,
		# 		horizontalAccuracy=0.1,
		# 		verticalAccuracy=0.1
		# 	)
		# ).wait(0.1)
		print("before sending gps")
		self.drone(
			olympe.messages.controller_info.gps(
				latitude=msg.latitude,
				longitude=msg.longitude,
				altitude=msg.altitude,
				horizontalAccuracy=0.1,
				verticalAccuracy=0.1,
				north_speed = 0,
				east_speed = 0,
				down_speed = 0,
				timestamp = rospy.Time.now().to_nsec()*1000
			)
		).wait()
		print("Updated the controller gps position")
		# self.drone(AllStates()).wait(0.1)


		
		print("\u001B[33mFollow me mode:",self.drone.get_state(olympe.messages.follow_me.state)["mode"])
		print("\u001B[33mFollow me behavior:",self.drone.get_state(olympe.messages.follow_me.state)["behavior"])
		print("\u001B[33mGPS fix",self.drone.get_state(GPSFixStateChanged)["fixed"])
		print("\u001B[33mGPS Location error lat",self.drone.get_state(GpsLocationChanged)["latitude_accuracy"])
		print("\u001B[33mGPS Location error lon",self.drone.get_state(GpsLocationChanged)["longitude_accuracy"])
		print("\u001B[33mGPS Location error alt",self.drone.get_state(GpsLocationChanged)["altitude_accuracy"])
		print("\u001B[33mMode info",self.drone.get_state(olympe.messages.follow_me.mode_info))

		# mode = self.drone.get_state(olympe.messages.follow_me.state)["missing_requirements"]
		# print("\u001B[33mMode from mode info:",self.drone.get_state(olympe.messages.follow_me.mode_info(mode=mode)))
		# print("\u001B[33mFollow me controller gps altitude:",self.drone.get_state(olympe.messages.controller_info.gps)["altitude"])
		# print("\u001B[33mController barometer pressure :",self.drone.get_state(olympe.messages.controller_info.barometer)["pressure"])
		# print("\u001B[33mMssing Requiredments for mode",self.drone.get_state(olympe.messages.follow_me.mode_info(mode=2))["missing_requirements"])

		print("\u001B[37m")
        
        # Check for potential errors
		# if follow_me_state['behavior'] == "idle":
		# 	print("Warning: Follow Me mode is idle.")
		# 	# Check GPS status of drone and controller
		# 	drone_gps = self.drone.get_state(olympe.messages.ardrone3.GPSSettingsState.GPSFixStateChanged)
		# 	print(f"Drone GPS Fix: {drone_gps['fixed']}, Number of Satellites: {drone_gps['satellites']}")
            
        # # Pause before next check
        # time.sleep(1)
		# # self.drone(olympe.messages.follow_me.mode_info # https://developer.parrot.com/docs/olympe/arsdkng_followme.html
			 
			 
		# 	 )
		return
		

	def zoom_callback(self, msg):
		self.drone(camera.set_zoom_target(  # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_zoom_target
			cam_id=0,
			control_mode='level' if msg.mode == 0 else 'velocity', # {'level', 'velocity'}
			target=msg.zoom)) # (in level mode [1,max_zoom])
		
	def gimbal_callback(self, msg):
		self.drone(gimbal.set_target(  # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.set_target
			gimbal_id=0,
			control_mode='position' if msg.mode == 0 else 'velocity', # {'position', 'velocity'}
			yaw_frame_of_reference='none',
			yaw=0.0,
			pitch_frame_of_reference=self.gimbal_frame,  # {'absolute', 'relative', 'none'}
			pitch=-msg.pitch,  # (in position mode [-135,105])
			roll_frame_of_reference=self.gimbal_frame,  # {'absolute', 'relative', 'none'}
			roll=msg.roll)) # (in position mode [-38,38])
		

	def spawn_point_callback(self,msg):
		self.msg_spawn_point = msg
		return
	
	def offboard(self, request):
		if request.data:	
			self.switch_offboard()
		else:
			self.switch_manual()
		return []
			
	def arm(self, request):
		if request.data:
			rospy.logwarn("Arming")
			assert self.drone(UserTakeOff(state = 1)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.UserTakeOff
		else:
			rospy.loginfo("Disarming")
			assert self.drone(Emergency() >> FlyingStateChanged(state="LANDED")).wait().success() # the fastest way to disarm
		return []

	def takeoff(self, request):
		rospy.logwarn("Taking off")
		assert self.drone(TakeOff()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.TakeOff
		#run_id = self.drone.get_state(olympe.messages.common.RunState.RunIdChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_runstate.html#olympe.messages.common.RunState.RunIdChanged  # TODO: move it to anafi listener
		#rospy.loginfo('Run Id: ', run_id['runId'])  # TODO: move it to anafi listener
		return []
	
	def land(self, request):		
		rospy.loginfo("Landing")
		assert self.drone(Landing()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.Landing
		flights_status = self.drone.get_state(olympe.messages.ardrone3.SettingsState.MotorFlightsStatusChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_settings_state.html#olympe.messages.ardrone3.SettingsState.MotorFlightsStatusChanged
		rospy.loginfo('Flight duration = %is', flights_status['lastFlightDuration'])
		return []
		
	def emergency(self, request):		
		assert self.drone(Emergency()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.Emergency
		
		if self.drone.get_state(olympe.messages.ardrone3.SoundState.AlertSound)["state"] == olympe.enums.ardrone3.SoundState.AlertSound_State.stopped: # DEPRECATED: https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_sound.html#olympe.messages.ardrone3.SoundState.AlertSound
			rospy.logfatal("Emergency!!!")
			self.drone(olympe.messages.ardrone3.Sound.StartAlertSound()) # DEPRECATED: https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_sound.html#olympe.messages.ardrone3.Sound.StartAlertSound
		else:
			self.drone(olympe.messages.ardrone3.Sound.StopAlertSound()) # DEPRECATED: https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_sound.html#olympe.messages.ardrone3.Sound.StopAlertSound
		return []
		
	def halt(self, request):  # calls all commands to halt
		rospy.logwarn("HALT!!!")
		self.drone(PCMD(flag=1, roll=0, pitch=0, yaw=0, gaz=0, timestampAndSeqNum=0))
		self.drone(NavigateHome(start=0))
		self.drone(StopPilotedPOI())
		self.drone(olympe.messages.common.Mavlink.Stop())
		self.drone(olympe.messages.follow_me.stop())
		self.drone(olympe.messages.rth.abort())
		return []
		
	def rth(self, request):		
		rospy.loginfo("Returning to Home")
		assert self.drone(return_to_home()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.return_to_home
		return []
	
	def reboot(self, request):
		rospy.logwarn("Rebooting...")
		assert self.drone(olympe.messages.common.Common.Reboot()).wait().success()  # https://developer.parrot.com/docs/olympe/arsdkng_common_common.html#olympe.messages.common.Common.Reboot
		return []
		
	def manager_discover(self, request):
		rospy.loginfo("Discovering drones...")
		self.drone(olympe.messages.drone_manager.discover_drones()).wait() # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.discover_drones
		drone_list = self.drone.get_state(olympe.messages.drone_manager.drone_list_item) # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.drone_list_item
		for drone in drone_list:
			rospy.loginfo("Drone: serial=%s, model=%i, name=%s, connection order=%s, connecting=%s, visible=%s, security=%s, saved key=%s, rssi=%i",
						  drone_list[drone]['serial'], drone_list[drone]['model'], drone_list[drone]['name'],
						  (drone_list[drone]['connection_order'] if drone_list[drone]['connection_order'] > 0 else 'never connected'),
						  ('yes' if drone_list[drone]['active'] == 1 else 'no'),
						  ('yes' if drone_list[drone]['visible'] == 1 else 'no'), drone_list[drone]['security'].name,
						  ('yes' if drone_list[drone]['has_saved_key'] == 1 else 'no'), drone_list[drone]['rssi'])
		return []
		
	def manager_forget(self, request):
		rospy.loginfo("Forgetting drone " + request.data)
		self.drone(olympe.messages.drone_manager.forget(serial=request.data)).wait().success()  # https://developer.parrot.com/docs/olympe/arsdkng_drone_manager.html#olympe.messages.drone_manager.forget
		return []
		
	def home_set(self, request):		
		rospy.loginfo("Setting Home")
		assert self.drone(olympe.messages.rth.set_custom_location( # https://developer.parrot.com/docs/olympe/arsdkng_rth.html#olympe.messages.rth.return_to_home
			latitude=request.latitude, # latitude of the takeoff location
			longitude=request.longitude, # longitude of the takeoff location
			altitude=request.altitude # altitude of the custom location above takeoff (ATO).		
			)).wait().success() 
		return []
		
	def home_navigate(self, request):
		if request.data: 	
			rospy.loginfo("Navigating Home")
			assert self.drone(PCMD(flag=1, roll=0, pitch=0, yaw=0, gaz=0, timestampAndSeqNum=0)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.PCMD
			assert self.drone(NavigateHome(start=1)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.NavigateHome
		else:
			rospy.loginfo("Stopping Navigation Home")		
			assert self.drone(NavigateHome(start=0)).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.NavigateHome
		navigate_home_state = self.drone.get_state(olympe.messages.ardrone3.PilotingState.NavigateHomeStateChanged) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingState.NavigateHomeStateChanged
		rospy.loginfo("Navigate Home State: state = %s, reason = %s",
					  navigate_home_state['state'].name, navigate_home_state['reason'].name)
		return []
		
	def POI_start(self, request):
		rospy.loginfo("Starting Piloted Point of Interest")		
		assert self.drone(StartPilotedPOIV2( # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.StartPilotedPOIV2
			latitude=request.latitude, # latitude of the location to look at (deg)
			longitude=request.longitude, # longitude of the location to look at (deg)
			altitude=request.altitude, # altitude above take off point to look at (m)
			mode=('locked_gimbal' if request.locked_gimbal else 'free_gimbal') # gimbal is locked on the POI OR freely controllable
			)).wait().success()
		piloted_poi_state = self.drone.get_state(olympe.messages.ardrone3.PilotingState.PilotedPOIV2) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingState.PilotedPOIV2
		rospy.loginfo("Piloted POI State: latitude = %f, longitude = %f, altitude = %f, mode = %s, status = %s",
					  piloted_poi_state['latitude'], piloted_poi_state['longitude'], piloted_poi_state['altitude'],
					  piloted_poi_state['mode'].name, piloted_poi_state['status'].name)
		return []
	
	def POI_stop(self, request):
		rospy.loginfo("Stopping Piloted Point of Interest")		
		assert self.drone(StopPilotedPOI()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.Piloting.StopPilotedPOI
		return []
			
	def flightplan_upload(self, request): # https://forum.developer.parrot.com/t/olympe-mavlink-working-example/14041/2	
		rospy.loginfo("FlightPlan uploading from " + request.filepath)
		rospy.loginfo("REST API: PUT http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan,  data=" + request.filepath)
		response = requestuests.put(url="http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan", data=open(request.filepath, "rb"))
		response.raise_for_status()
		self.uid = response.json()
		rospy.loginfo("FlightPlan uploaded with UID " + self.uid)
		return []	
		
	def flightplan_start(self, request): # https://forum.developer.parrot.com/t/olympe-mavlink-working-example/14041/2
		uid = (request.uid if request.uid != "" else self.uid)
		rospy.logwarn("FlightPlan starting with UID " + uid)
		rospy.logdebug("REST API: GET http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan/" + uid)
		response = requestuests.get("http://" + self.ip + ":180/api/v" + self.rest_api_version + "/upload/flightplan/" + uid)
		response.raise_for_status()
		if response.status_code == requestuests.codes.ok:
			self.drone(
				olympe.messages.common.Mavlink.Start( # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.messages.common.Mavlink.Start
				filepath=uid, # TODO: check why sometimes doesn't take the filepath
				type='flightPlan' # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.enums.common.Mavlink.Start_Type
				)).wait()
				
			if self.drone.get_state(olympe.messages.common.FlightPlanState.AvailabilityStateChanged)['AvailabilityState'] == 0: # https://developer.parrot.com/docs/olympe/arsdkng_common_flightplan.html#olympe.messages.common.FlightPlanState.AvailabilityStateChanged
				components = self.drone.get_state(olympe.messages.common.FlightPlanState.ComponentStateListChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_flightplan.html#olympe.messages.common.FlightPlanState.ComponentStateListChanged
				for component in components:
					if components[component]['State'] == 0:
						rospy.logwarn("FlightPlan: %s is NOT OK", str(components[component]['component'].name))
					else:
						rospy.loginfo("FlightPlan: %s is OK", str(components[component]['component'].name))
		else:
			rospy.logwarn("UID " + uid + " does not exist onboard")
		return []
		
	def flightplan_pause(self, request):
		rospy.loginfo("FlightPlan pausing")
		assert self.drone(olympe.messages.common.Mavlink.Pause()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.messages.common.Mavlink.Pause
		return []
		
	def flightplan_stop(self, request):
		rospy.loginfo("FlightPlan stopping")
		assert self.drone(olympe.messages.common.Mavlink.Stop()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_common_mavlink.html#olympe.messages.common.Mavlink.Stop
		return []
		
	def followme_start(self, request):
		rospy.logwarn("FollowMe starting with " + olympe.enums.follow_me.mode(request.mode).name)

		self.drone(olympe.messages.follow_me.set_target_is_controller( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.set_target_is_controller
			target_is_controller = 1, # do not use default
		)).wait()
		

		rospy.logwarn("FollowMe starting with controller is target: " + str(bool(self.drone.get_state(olympe.messages.follow_me.target_is_controller)["state"])))

		
		self.drone(olympe.messages.follow_me.target_framing_position( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.target_framing_position
			horizontal=request.horizontal,
			vertical=request.vertical
			)).wait()
		self.drone(olympe.messages.follow_me.target_image_detection( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.target_image_detection
			target_azimuth=request.target_azimuth,
			target_elevation=request.target_elevation,
			change_of_scale=request.change_of_scale,
			confidence_index=request.confidence_index,
			is_new_selection=request.is_new_selection,
			timestamp = int(rospy.Time.now().to_sec()*1000)
			)).wait()



		self.drone(olympe.messages.follow_me.configure_geographic( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.configure_geographic
			use_default = 0, # do not use default
			distance = 10, # m
			elevation = 0, # rad
			azimuth = 0, # rad
		)).wait()

		self.drone(olympe.messages.follow_me.start( # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.start
			mode=olympe.enums.follow_me.mode(request.mode) # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.enums.follow_me.mode
			)).wait()
		return []
			
	def followme_stop(self, request):
		rospy.loginfo("FollowMe stopping")
		assert self.drone(olympe.messages.follow_me.stop()).wait().success() # https://developer.parrot.com/docs/olympe/arsdkng_followme.html#olympe.messages.follow_me.stop
		return []
		
	def magnetometer_calibrate(self, request):
		# if self.drone.get_state(olympe.messages.common.CalibrationState.MagnetoCalibrationRequiredState)['required'] == 1: # https://developer.parrot.com/docs/olympe/arsdkng_common_calibration.html#olympe.messages.common.CalibrationState.MagnetoCalibrationrequestuiredState
		rospy.logwarn("Magnetometer calibration started")
		self.drone(olympe.messages.common.Calibration.MagnetoCalibration(calibrate=1)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_common_calibration.html#olympe.messages.common.Calibration.MagnetoCalibration
		calibrating_axis = -1
		while True:
			calibration_axis = self.drone.get_state(olympe.messages.common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged)['axis']
			if calibration_axis is olympe.enums.common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged_Axis.none:
				break
			if calibrating_axis != calibration_axis.value:
				rospy.logwarn("Rotate the drone around " + calibration_axis.name)
				calibrating_axis = calibration_axis.value				
			rospy.sleep(1)
		state = self.drone.get_state(olympe.messages.common.CalibrationState.MagnetoCalibrationStateChanged) # https://developer.parrot.com/docs/olympe/arsdkng_common_calibration.html#olympe.messages.common.CalibrationState.MagnetoCalibrationStateChanged
		if state['calibrationFailed'] == 1:
			rospy.logfatal("Calibration failed")
		if state['xAxisCalibration'] == 1 and state['yAxisCalibration'] == 1 and state['zAxisCalibration'] == 1:
			rospy.loginfo("Calibration completed")
		else:
			rospy.logwarn("Calibration status: x-axis - %s, y-axis - %s, z-axis - %s",
							('completed' if state['xAxisCalibration'] else 'failed'),
							('completed' if state['yAxisCalibration'] else 'failed'),
							('completed' if state['zAxisCalibration'] else 'failed'))
		# else:
		# 	rospy.loginfo("Magnetometer calibration is not required")
		return []
		
	def gimbal_calibrate(self, request):
		if self.drone.get_state(olympe.messages.gimbal.calibration_state)[0]['state'] == olympe.enums.gimbal.calibration_state.requestuired: # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.calibration_state
			rospy.loginfo("Calibrating gimbal")
			self.drone(olympe.messages.gimbal.calibrate(gimbal_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.calibrate
		else:
			rospy.loginfo("Gimbal calibration is not required")
		return []
		
	def gimbal_reset(self, request):
		rospy.logdebug("Reseting gimbal")
		self.drone(olympe.messages.gimbal.reset_orientation(gimbal_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_gimbal.html#olympe.messages.gimbal.reset_orientation
		return []
		
	def zoom_reset(self, request):        	
		rospy.logdebug("Reseting zoom")
		self.drone(camera.reset_zoom(cam_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.reset_zoom
		return []
			
	def photo_take(self, request):
		rospy.loginfo("Taking photo")
		self.drone(camera.set_camera_mode(cam_id=0, value="photo")).wait()
		self.drone(camera.take_photo(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.take_photo
		self.drone(camera.set_camera_mode(cam_id=0, value="recording" if self.camera_mode == 0 else "photo"))
		return []
	
	# def photo_take_and_download(self,request):

	# 	self.drone(
    #     set_photo_mode(
    #         cam_id=0,
    #         mode="single",
    #         format="rectilinear",
    #         file_format="jpeg",
    #         burst="burst_14_over_4s",
    #         bracketing="preset_1ev",
    #         capture_interval=0.0,
    #     )
    # 	).wait()

	# 	# Drone web server URL
	# 	anafi_url = "http://{}/".format(self.ip)

	# 	# Drone media web API URL
	# 	anafi_media_api_url = anafi_url + "api/v1/media/medias/"
	# 	XMP_TAGS_OF_INTEREST = (
	# 		"CameraRollDegree",
	# 		"CameraPitchDegree",
	# 		"CameraYawDegree",
	# 		"CaptureTsUs",
	# 		# NOTE: GPS metadata is only present if the drone has a GPS fix
	# 		# (i.e. they won't be present indoor)
	# 		"GPSLatitude",
	# 		"GPSLongitude",
	# 		"GPSAltitude",
	# 	)
	# 	#Take photo
	# 	rospy.loginfo("Taking photo")
	# 	photo_saved = self.drone(photo_progress(result="photo_saved", _policy="wait"))
	# 	print("after photo_progress")
	# 	self.drone(take_photo(cam_id=0)).wait()
	# 	print("after take_photo")
	# 	photo_saved.wait()
	# 	print("after photo_saved.wait()")
	# 	media_id = photo_saved.received_events().last().args["media_id"]
	# 	print("taking photo done")
	# 	# download the photos associated with this media id
	# 	media_info_response = requests.get(anafi_media_api_url + media_id)
	# 	media_info_response.raise_for_status()
	# 	download_dir = tempfile.mkdtemp()
	# 	for resource in media_info_response.json()["resources"]:
	# 		image_response = requests.get(anafi_url + resource["url"], stream=True)
	# 		download_path = os.path.join(download_dir, resource["resource_id"])
	# 		image_response.raise_for_status()
	# 		with open(download_path, "wb") as image_file:
	# 			shutil.copyfileobj(image_response.raw, image_file)

	# 		# parse the xmp metadata
	# 		with open(download_path, "rb") as image_file:
	# 			image_data = image_file.read()
	# 			image_xmp_start = image_data.find(b"<x:xmpmeta")
	# 			image_xmp_end = image_data.find(b"</x:xmpmeta")
	# 			image_xmp = ET.fromstring(image_data[image_xmp_start : image_xmp_end + 12])
	# 			for image_meta in image_xmp[0][0]:
	# 				xmp_tag = re.sub(r"{[^}]*}", "", image_meta.tag)
	# 				xmp_value = image_meta.text
	# 				# only print the XMP tags we are interested in
	# 				if xmp_tag in XMP_TAGS_OF_INTEREST:
	# 					print(resource["resource_id"], xmp_tag, xmp_value)

	# 	return []

	def photo_stop(self, request):
		rospy.loginfo("Stopping photo")
		self.drone(camera.stop_photo(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.stop_photo
		self.drone(camera.set_camera_mode(cam_id=0, value="recording" if self.camera_mode == 0 else "photo"))
		return []
		
	def recording_start(self, request):
		rospy.loginfo("Starting recording")
		self.drone(camera.set_camera_mode(cam_id=0, value="recording")).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.set_camera_mode
		self.drone(camera.start_recording(cam_id=0)) # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.start_recording
		return []
		
	def recording_stop(self, request):
		rospy.loginfo("Stopping recording")
		self.drone(camera.stop_recording(cam_id=0)).wait() # https://developer.parrot.com/docs/olympe/arsdkng_camera.html#olympe.messages.camera.stop_recording
		self.drone(camera.set_camera_mode(cam_id=0, value="recording" if self.camera_mode == 0 else "photo"))
		return []
		
	def media_download(self, request):
		if self.drone.media(indexing_state(state="indexed")).wait(_timeout=10).success():  # FIXME: fails on some drones
			media_id = olympe.Media.list_media(self.drone.media)
			num_media = len(media_id)

			if num_media > 0:
				if not os.path.exists(self.download_folder):  # check if folder exists
					os.mkdir(self.download_folder)
					rospy.loginfo("Folder '%s' created", self.download_folder)
				self.drone.media.download_dir = self.download_folder  # download the photos associated with this media id

				rospy.loginfo("Downloading %i media", num_media)

				media_count = 1
				for media in media_id:
					media_info = olympe.Media.media_info(self.drone.media, media_id = media)
					rospy.loginfo("Media %i/%i: downloading %.1fMB", media_count, num_media, media_info.size/(2**20))
					media_download = self.drone(download_media(media))
					resources = media_download.as_completed(timeout=100)
					rospy.loginfo("Media %i/%i: downloaded %.1fMB", media_count, num_media, media_info.size/(2**20))

					for resource in resources:
						if not resource.success():
							rospy.logerr("Failed to download %s", str(resource.resource_id))
							continue

					media_count += 1

				if self.cut_media:
					self.drone(delete_all_media())
			else:
				rospy.loginfo("No media found")
		else:
			rospy.logwarn("Media is not indexed :(")
		return []
		
	def storage_format(self, request):
		info = self.drone.get_state(olympe.messages.user_storage.info)  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.info
		if info['name'] != "":
			rospy.loginfo("Formatting media %s (%.1fGB)", info['name'], info['capacity']/(2**30))
			self.drone(olympe.messages.user_storage.format_with_type(  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.format_with_type
				label="",
				type=olympe.enums.user_storage.formatting_type(0))  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.enums.user_storage.formatting_type
				>>
				olympe.messages.user_storage.start_monitoring(period=1))  # https://developer.parrot.com/docs/olympe/arsdkng_user_storage.html#olympe.messages.user_storage.start_monitoring
		else:
			rospy.logwarn("There is no media to format")
		return []
	
	


		
	def fast_callback(self, event):
		#motion_state = self.drone.get_state(olympe.messages.ardrone3.PilotingState.MotionState)['state'] # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_piloting.html#olympe.messages.ardrone3.PilotingState.MotionState  # TODO: consider moving it to anafi listener
		#self.pub_steady.publish(self.state == "LANDED" and motion_state == olympe.enums.ardrone3.PilotingState.MotionState_State.steady)  # TODO: consider moving it to anafi listener

		if self.skycontroller_enabled:
			self.msg_skycontroller.header.stamp = rospy.Time.now()
			self.pub_skyctrl_command.publish(self.msg_skycontroller)
			# Reset button pressing message
			self.msg_skycontroller.return_home = False
			self.msg_skycontroller.takeoff_land = False
			self.msg_skycontroller.reset_camera = False
			self.msg_skycontroller.reset_zoom = False
			
	def slow_callback(self, event):	
		#self.gps_fixed = bool(self.drone.get_state(olympe.messages.ardrone3.GPSSettingsState.GPSFixStateChanged)['fixed']) # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_gps.html#olympe.messages.ardrone3.GPSSettingsState.GPSFixStateChanged  FIXME: check if the state is initialised - e.g., using IMU
		#self.pub_gps_fix.publish(self.gps_fixed)
			
		home = self.drone.get_state(olympe.messages.ardrone3.GPSSettingsState.HomeChanged)  # https://developer.parrot.com/docs/olympe/arsdkng_ardrone3_gps.html#olympe.messages.ardrone3.GPSSettingsState.HomeChanged  FIXME: check if the state is initialised - e.g., using IMU
		if home['latitude'] != 500 and home['longitude'] != 500 and home['altitude'] != 500: 
			
			self.msg_home_location.header.stamp = rospy.Time.now()
			self.msg_home_location.header.frame_id = '/world'
			self.msg_home_location.point.x = home['latitude']
			self.msg_home_location.point.y = home['longitude']
			self.msg_home_location.point.z = home['altitude']
			self.pub_home_location.publish(self.msg_home_location)
							
		self.pub_battery_health.publish(self.drone.get_state(olympe.messages.battery.health)['state_of_health'])  # https://developer.parrot.com/docs/olympe/arsdkng_battery.html#olympe.messages.battery.health  FIXME: check if the state is initialised - e.g., using IMU
		
	def yuv_frame_cb(self, yuv_frame):  # this function will be called by Olympe for each decoded YUV frame
		yuv_frame.ref()
		if self.frame_queue.full():
			self.frame_queue.get_nowait().unref()
		self.frame_queue.put_nowait(yuv_frame)

	def flush_cb(self, stream):
		if stream["vdef_format"] != olympe.VDEF_I420:
			return True
		while not self.frame_queue.empty():
			self.frame_queue.get_nowait().unref()
		return True
	
	def gps_to_ecef_pyproj(self,lat, lon, alt):
		ecef = pp.Proj(proj='geocent', ellps='WGS84', datum='WGS84')
		lla = pp.Proj(proj='latlong', ellps='WGS84', datum='WGS84')
		x, y, z = pp.transform(lla, ecef, lon, lat, alt, radians=False)

		return x, y, z

	def yuv_frame_processing(self):
		while self.running:
			try:
				yuv_frame = self.frame_queue.get(timeout=0.1)
			except queue.Empty:
				continue

			info = yuv_frame.info()  # the VideoFrame.info() dictionary contains some useful information such as the video resolution
			rospy.logdebug_throttle(10, "yuv_frame.info = " + str(info))

			vmeta = yuv_frame.vmeta()  # yuv_frame.vmeta() returns a dictionary that contains additional metadata from the drone
			rospy.logdebug_throttle(10, "yuv_frame.vmeta = " + str(vmeta))

			

			if vmeta[1] != {}:
				self.header.stamp = rospy.Time.now()
				
				frame_timestamp = info['raw']['frame']['timestamp']  # timestamp (millisec)
				self.msg_time.data = frame_timestamp  # TODO: check correctness -> secs = int(frame_timestamp//1e6), nsecs = int(frame_timestamp%1e6*1e3)
				self.pub_time.publish(self.msg_time)

				

				

				ground_distance = vmeta[1]['drone']['ground_distance']  # barometer (m)
				self.pub_altitude.publish(ground_distance)


				location = vmeta[1]["drone"]["location"]
				self.msg_location.header.frame_id = '/world'
				self.msg_location.header.stamp = rospy.Time.now()
				self.msg_location.latitude = location["latitude"]
				self.msg_location.longitude = location["longitude"]
				self.msg_location.altitude = location["altitude_egm96amsl"]
				self.pub_location.publish(self.msg_location)
				
				origin_ECEF,R_ECEF2NED = GPS2ECEF(self.msg_home_location.point.x,self.msg_home_location.point.y,0,1)
				location_ned = GPS2NED(location["latitude"], location["longitude"], location["altitude_egm96amsl"], origin_ECEF, R_ECEF2NED)
				#Notice the order of points in the array
				location_ned_corrected = location_ned + np.array([[self.msg_spawn_point.point.y],[self.msg_spawn_point.point.x],[self.msg_spawn_point.point.z]])
				# print("---")
				# print( location_ned_corrected)

				msg_position_enu = PointStamped()
				msg_position_enu.header.stamp = rospy.Time.now()
				msg_position_enu.header.frame_id = '/world'
				msg_position_enu.point.x = location_ned_corrected[1] 
				msg_position_enu.point.y = location_ned_corrected[0] 
				msg_position_enu.point.z = -location_ned_corrected[2] 


				drone_quat = vmeta[1]['drone']['quat']  # attitude


				msg_pose_enu = PoseStamped()
				msg_pose_enu.header.stamp = rospy.Time.now()
				msg_pose_enu.header.frame_id = '/world'
				msg_pose_enu.pose.position = msg_position_enu.point
				#Rotate quaternion by 90 degree because rotation does not start at north position anymore but at east position
				q_rot = np.array([0,0,np.sqrt(2)/2,np.sqrt(2)/2])
				q_orig = np.array([drone_quat['x'],drone_quat['y'],drone_quat['z'],drone_quat['w']])
				q_result = quaternion_multiply(q_rot,q_orig)
				q_result = np.array([q_result[1],q_result[0],q_result[3],q_result[2]])

				
				msg_pose_enu.pose.orientation.x = q_result[0]
				msg_pose_enu.pose.orientation.y = q_result[1]
				msg_pose_enu.pose.orientation.z = q_result[2]
				msg_pose_enu.pose.orientation.w = q_result[3]

				self.pub_position_enu.publish(msg_position_enu)
				self.pub_pose_enu.publish(msg_pose_enu)




				
				self.msg_attitude.header = self.header
				self.msg_attitude.header.frame_id = '/world'
				self.msg_attitude.quaternion = Quaternion(q_result[0], q_result[1], q_result[2],q_result[3])
				self.pub_attitude.publish(self.msg_attitude)
				(roll, pitch, yaw) = euler_from_quaternion(q_result)
				self.msg_rpy.header = self.header
				self.msg_rpy.header.frame_id = '/world'
				self.msg_rpy.vector.x = roll
				self.msg_rpy.vector.y = pitch
				self.msg_rpy.vector.z = yaw
				self.pub_rpy.publish(self.msg_rpy)


				

				speed = vmeta[1]['drone']['speed']  # opticalflow speed (m/s)
				self.msg_speed.header = self.header
				self.msg_speed.header.frame_id = '/world'
				self.msg_speed.vector.x = speed['east']
				self.msg_speed.vector.y = speed['north']
				self.msg_speed.vector.z = -speed['down']
				self.pub_speed.publish(self.msg_speed)


				time_now = rospy.Time.now()
				self.msg_control_state.header.frame_id = "/world"
				self.msg_control_state.header.stamp = time_now
				self.msg_control_state.pose.header.frame_id = "/world"
				self.msg_control_state.pose.header.stamp = time_now
				self.msg_control_state.twist.header.frame_id = "/world"
				self.msg_control_state.twist.header.stamp = time_now
				self.msg_control_state.twist.twist.linear.header.frame_id = "/world"
				self.msg_control_state.twist.twist.linear.header.stamp = time_now
				self.msg_control_state.pose.pose.position.x = msg_pose_enu.pose.position.x
				self.msg_control_state.pose.pose.position.y = msg_pose_enu.pose.position.y
				self.msg_control_state.pose.pose.position.z = msg_pose_enu.pose.position.z
				self.msg_control_state.pose.pose.orientation.x = msg_pose_enu.pose.orientation.x
				self.msg_control_state.pose.pose.orientation.y = msg_pose_enu.pose.orientation.y
				self.msg_control_state.pose.pose.orientation.z = msg_pose_enu.pose.orientation.z
				self.msg_control_state.pose.pose.orientation.w = msg_pose_enu.pose.orientation.w
				self.msg_control_state.twist.twist.linear.vector.x = self.msg_speed.vector.x
				self.msg_control_state.twist.twist.linear.vector.y = self.msg_speed.vector.y
				self.msg_control_state.twist.twist.linear.vector.z = self.msg_speed.vector.z
				self.msg_control_state.twist.twist.angular.vector.x = 0
				self.msg_control_state.twist.twist.angular.vector.y = 0
				self.msg_control_state.twist.twist.angular.vector.z = 0

				self.pub_control_state.publish(self.msg_control_state)

				battery_percentage = vmeta[1]['drone']['battery_percentage']  # [0=empty, 100=full]
				self.pub_battery.publish(battery_percentage)
				if battery_percentage%10 == 0:
					rospy.loginfo_throttle(100, "Battery level: " + str(battery_percentage) + "%")

				camera_quat = vmeta[1]['camera']['quat']
				self.msg_attitude.header.frame_id = '/body'
				self.msg_attitude.quaternion = Quaternion(camera_quat['x'], -camera_quat['y'], -camera_quat['z'], camera_quat['w'])
				self.pub_camera_attitude.publish(self.msg_attitude)

				camera_base_quat = vmeta[1]['camera']['base_quat']
				self.msg_attitude.header.frame_id = '/body'
				self.msg_attitude.quaternion = Quaternion(camera_base_quat['x'], -camera_base_quat['y'], -camera_base_quat['z'], camera_base_quat['w'])
				self.pub_camera_base_attitude.publish(self.msg_attitude)

				exposure_time = vmeta[1]['camera']['exposure_time']
				self.pub_exposure_time.publish(exposure_time)

				iso_gain = vmeta[1]['camera']['iso_gain']
				self.pub_iso_gain.publish(iso_gain)

				awb_r_gain = vmeta[1]['camera']['awb_r_gain']
				self.pub_awb_r_gain.publish(awb_r_gain)

				awb_b_gain = vmeta[1]['camera']['awb_b_gain']
				self.pub_awb_b_gain.publish(awb_b_gain)

				hfov = vmeta[1]['camera']['hfov']
				self.pub_hfov.publish(hfov)

				vfov = vmeta[1]['camera']['vfov']
				self.pub_vfov.publish(vfov)

				fs_state = vmeta[1]['drone']['flying_state']  # ['FS_LANDED', 'FS_TAKINGOFF', 'FS_HOVERING', 'FS_FLYING', 'FS_LANDING', 'FS_EMERGENCY', 'FS_USER_TAKEOFF', 'FS_MOTOR_RAMPING', 'FS_EMERGENCY_LANDING']
				if fs_state.startswith("FS_"):  # in Olympe 7.4, "FS_" prefix was introduced
					fs_state = fs_state[3:]  # removes 'FS_' from the state value
				self.state = fs_state
				self.pub_state.publish(self.state)

				goodput = vmeta[1]['links'][0]['wifi']['goodput']  # throughput of the connection (b/s)
				self.pub_link_goodput.publish(goodput)

				quality = vmeta[1]['links'][0]['wifi']['quality']  # [0=bad, 5=good]
				self.pub_link_quality.publish(quality)

				rssi = vmeta[1]['links'][0]['wifi']['rssi']  # signal strength [-100=bad, 0=good] (dBm)
				self.pub_wifi_rssi.publish(rssi)

				# log signal strength
				if rssi <= -60:
					if rssi >= -70:
						rospy.loginfo_throttle(100, "Signal strength: " + str(rssi) + "dBm")
					else:
						if rssi >= -80:
							rospy.logwarn_throttle(10, "Weak signal: " + str(rssi) + "dBm")
						else:
							if rssi >= -90:
								rospy.logerr_throttle(1, "Unreliable signal:" + str(rssi) + "dBm")
							else:
								rospy.logfatal_throttle(0.1, "Unusable signal: " + str(rssi) + "dBm")

				cv2_cvt_color_flag = {  # convert pdraw YUV flag to OpenCV YUV flag
					olympe.VDEF_I420: cv2.COLOR_YUV2BGR_I420,
					olympe.VDEF_NV12: cv2.COLOR_YUV2BGR_NV12,
				}[yuv_frame.format()]
				cv2frame = cv2.cvtColor(yuv_frame.as_ndarray(), cv2_cvt_color_flag)  # use OpenCV to convert the yuv frame to RGB

				msg_image = self.bridge.cv2_to_imgmsg(cv2frame, "bgr8")
				timestamp = info['ntp_raw_unskewed_timestamp']  # image capture timestamp (ms)
				msg_image.header.stamp.secs = int(timestamp//1e6)
				msg_image.header.stamp.nsecs = int((timestamp%1e6)*1e3)
				self.pub_image.publish(msg_image)

				self.msg_camera_info.header = self.header
				self.msg_camera_info.header.frame_id = '/camera'
				self.pub_camera_info.publish(self.msg_camera_info)
			else:
				rospy.logwarn("Frame lost!")

			yuv_frame.unref()
				
	def switch_manual(self):
		self.msg_skycontroller = SkycontrollerCommand()
		self.msg_skycontroller.header.stamp = rospy.Time.now()
		self.pub_skyctrl_command.publish(self.msg_skycontroller)
		
		# button: 	0 = return home, 1 = takeoff/land, 2 = back left, 3 = back right
		self.drone(mapper.grab(buttons=(0<<0|0<<1|0<<2|1<<3), axes=0)).wait() # bitfields
		self.drone(setPilotingSource(source="SkyController")).wait()
		rospy.logwarn("Control: Manual")
			
	def switch_offboard(self):
		# button: 	0 = return home, 1 = takeoff/land, 2 = back left, 3 = back right
		# axis: 	0 = yaw, 1 = trottle, 2 = roll, 3 = pithch, 4 = camera, 5 = zoom
		self.drone(mapper.grab(buttons=(1<<0|0<<1|1<<2|1<<3), axes=(1<<0|1<<1|1<<2|1<<3|1<<4|1<<5))) # bitfields
		self.drone(setPilotingSource(source="Controller")).wait()
		rospy.logwarn("Control: Offboard")
				
	def run(self): 	
		rate = rospy.Rate(100)  # 100hz
		
		while not rospy.is_shutdown():
			if not self.drone.connection_state():
				rospy.logfatal('Drone disconnected!!!')
				self.disconnect()
				rospy.loginfo('Reconnecting to the drone...')
				self.connect()

			rate.sleep()


if __name__ == '__main__':
	rospy.init_node('anafi', anonymous = False)
	rospy.loginfo("Anafi_bridge is running...")
	anafi = Anafi()	
	try:
		anafi.run()
	except rospy.ROSInterruptException:
		pass
